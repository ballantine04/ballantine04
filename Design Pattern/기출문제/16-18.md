![21](https://user-images.githubusercontent.com/69576676/132937972-fdc9375b-e9d6-4ee3-8de7-d20f5235c8ab.JPG)

문제 
----
#### [수민]
#### 16:  Abstract Class ( Server ) 를 만들어 Server1/Server2 가 추상화에 의존하도록 함. ( DIP = Factory Method 에서 사용 )
```java
class Caller {	
    public void request1(Server a) {
        a.method1();
    }
    public void request2(Server b, String s){
        b.method2(s);
    }  
}

abstract class Server {
	public void method1() {}
	public void method2(String s) {}
}

class Server1 extends Server{
  public void method1(){
     System.out.println("method1 invoked");
  }
}

class Server2 extends Server{
  public void method2(String s){
     System.out.println("method1 invoked "+s);
  }
}


public class test {
	public static void main(String[] args) {
		Server srv1 = new Server1();
		Server srv2 = new Server2();
		
		Caller caller = new Caller();
		caller.request1(srv1);
		caller.request2(srv2, "ABC");
	}
}
[output]
method1 invoked
method1 invoked ABC
```
#### 17: 틀림. SRP를 위반하지 않기 위해서는 flag 파라메터로 분기하는 것이 아니라 별도의 Class를 만들어 responsibility를 분리해야 한다.
##### 교제 예시1) Student Class를 정렬하는 방식을 같이 구현하는 것이 아니라 방식에 따라 Class를 별도 생성. SortStudentBySSN, SortStudentByName
##### 교제 예시2) 추상클래스(Rectangle) 을 생성 후, CGA Class와 GA Class를 responsibility로 분리

#### 18:
#### [Abstract Factory ]
```java
// Abstract Factory 
abstract class CarFactory {
	public abstract void createCar(); 
}
// Concrete Factory1
class SedanFactory extends CarFactory {
	Engine engine = null;
	Wheel wheel = null;
	Body body = null;
	
	public void createCar() {
		engine = new SedanEngine();
		wheel = new SedanWheel();
		body = new SedanBody();	
	} 
}
// Concrete Factory2
class SportsFactory extends CarFactory {
	Engine engine = null;
	Wheel wheel = null;
	Body body = null;
	
	public void createCar() {
		engine = new SportsEngine();
		wheel = new SportsWheel();
		body = new SportsBody();	
	} 
}

// Product1
interface Engine {}

class SedanEngine implements Engine{
	public SedanEngine() { 
		System.out.println("Create Sedan Engine!"); 
	}
}

class SportsEngine implements Engine{
	public SportsEngine() {
		System.out.println("Create Sports Engine!");
	}
}
//Product2
interface Wheel {}

class SedanWheel implements Wheel{
	public SedanWheel() {
		System.out.println("Create Sedan Wheel!");
	}
}
class SportsWheel implements Wheel{
	public SportsWheel() {
		System.out.println("Create Sports Wheel!");
	}
}
//Product3
interface Body {}

class SedanBody implements Body{
	public SedanBody() {
		System.out.println("Create Sedan Body!");
	}
}
class SportsBody implements Body{
	public SportsBody() {
		System.out.println("Create Sports Body!");
	}
}
// Client
public class abstract_factory {
	public static void main(String[] args) {
		CarFactory carFactory = null;
		
		System.out.println("[Sedan Car 만들기]");
		carFactory = new SedanFactory();
		carFactory.createCar();
		
		System.out.println("[Sports Car 만들기]");
		carFactory = new SportsFactory();
		carFactory.createCar();
	}
}
[output]

[Sedan Car 만들기]
Create Sedan Engine!
Create Sedan Wheel!
Create Sedan Body!
[Sports Car 만들기]
Create Sports Engine!
Create Sports Wheel!
Create Sports Body!
```
